# ppt文案

[TOC]

这个东西宏观是干什么的

这个东西由什么构成的

各个模块是干什么的

整体流程是怎么样的

(可选)是否由其他形式,选择这样微架构的作用是什么?

## 时钟树

1. 时钟源,产生时钟
2. 数选器,配置寄存器选择需要的时钟源
3. 锁相环,倍频已有时钟
4. CSS时钟安全系统,对外部高速时钟进行监测,外部高速时钟
出现故障会直接切换回内部高速时钟,并触发中断
5. 分频器,也是寄存器可配置对已有时钟进行分频获取需要的时钟
6. 门控时钟,在不同电源模式下可关断时钟,减低功耗
7. MCO内部时钟输出,引出可检测时钟信号

## 电源

==datasheet的电源方案有断路==
注意:模拟域的参考电压小于电源电压,且参考电压代表的是ADC的满量程,且需要稳定

## 系统框图

没啥好说的,==唯一不确定的点是AHB_lite是AHB2AHB还是AHB的一个mux==

## cortex-M3

>Icode和Dcode和System这样设计的目的是什么?

1. I和D与S访问地址不同,可以同时传输,可以做到哈佛结构的优势;==但如果I和S同时取指令或者取向量时会怎么样?大概可能是会在AHB中插入等待==
2. I和D访问地址相同,不可同时传输,目的我觉得可能是考虑到了AHB的流水线结构;指令和文字池常量的地址可能比较比较大,如果在一个总线上的话,AHB主机就需要反复装填地址,会很麻烦;同时ARM建议Dcoed的优先级要高于指令,可能是为了防止数据相关性问题

>三种总线接口访问的场景都是什么

1. Icode:
   1. 指令寄存器取指令(注意只能读)
   2. PC寄存器取地址(注意只能读)
2. Dcode:
   1. 访存指令
   2. 调试命令
3. System:
   1. 访存指令
   2. 指令寄存器取指令
   3. PC寄存器取地址
   4. 调试命令

## DMA

1. IO数据传输方式 [了解更多点这里](https://www.jianshu.com/p/d1542085afde)
   1. 循环IO测试(CPU完全介入,无需额外硬件)
   CPU通过轮询检测IO的空/闲标志,去缓慢驱动外设
   2. 程序中断IO方式(CPU部分介入,增加中断控制)
   CPU写入/读取外设控制缓冲区,缓冲区空/满触发中断让CPU响应;
   缓冲区基本上不会太大,可能是给几级FIFO;
   反复中断对于处理器的代价也不小(拉满12个周期);
   当IO设备很多时,CPU可能只能处理中断
   3. DMA方式(CPU部分介入,增加中断控制,增加DMA)
    在内存和IO设备之间直接进行数据交换，不需要CPU的干预。当需要IO数据传输时，CPU将DMA初始化，之后DMA接管总线的使用权，将所需要的数据全部读入内存后，IO设备的控制器才会发出中断;
    这样可以有效降低中断次数,输出很多字符时有可观的性能;
    但值得注意DMA往往比CPU慢的多,如果DMA工作时CPU没啥事情做,那么说不定上两种方式会更好;
   4. 通道方式
   针对IO设备众多,输入输出频繁的,以上三种方式还是太慢其本质是针对不同外设类型的协处理器,dma只能配置参数
    ,而通道可以根据CPU的指令去初始化设备,搬运数据,收尾设备.
2. DMA原理
   1. 外设产生一个相关事件后，会将 DMA 请求信号发送到 DMA 控制器对应通道
   2. 按照软件(DMA_CCRx)配置的DMA 通道优先级，或者硬件默认规则，DMA 控制器依次处理这些请求,(加载源地址数据，地址由软件配置)(存储数据到目的地址，地址由软件配置)
   3. DMA 响应外设请求，通过总线访问外设的同时(执行一次 DMA 传输，计数器 DMA_CNDTRx 从配置的传输数量开始递减，表示剩余还有多少次 DMA 传输)，DMA 控制器会发送给外设一个应答信号，告知外设本次请求已响应
   4. 外设得到 DMA 的应答信号后，会立即释放掉本次请求
   5. DMA 侦测到外设请求消失后，对应的应答信号也会随之释放掉，本次 DMA 传输完成
   6. 注意DMA会占据系统总线,为了总体性能,总线仲裁器会进行调度,可能是round-robin型的冲裁方式
   7. 注意在一个通道,只能一个时间有一个使能(来源网上),优先级是给不同的通道使用的
3. ==DMA寄存器控制,也是有slave接口的但我看框图上没画,不知道是直接接在矩阵上还是?==

## USB OTG

1. 接口补充:
   1. USBDP:差分数据D+
   2. USBDM:差分数据D-
   3. USB-ID:USB器件识别
   4. USB_VBUS:主机电源,如果是主机供给电源
   5. USB_VBUS_ON:外部电源芯片使能信号
2. 结构包含:
   1. 外部FS PHY
   2. 内部OTG FS
   3. 内置DMA或FIFO
3. USB总线属于一种轮询式总线，主机控制端口初始化所有的数据传输。每一总线动作最多传送三个数据包，包括令牌(Token)、数据(Data)、联络(HandShake)。按照传输前制定好的原则，在每次传送开始时，主机送一个描述传输动作的种类、方向、USB设备地址和终端号的USB数据包，这个数据包通常被称为令牌包(TokenPacket)。USB设备从解码后的数据包的适当位置取出属于自己的数据。数据传输方向不是从主机到设备就是从设备到主机。

## Bus Matrix

1. 结构划分
   1. input stage
      组合送出数据或暂存数据
   2. decoder(+MUX)
      1. 与AHB_lite的decoder一样用于由地址选出正确的从机(给予HSEL信号)
      2. 同时也处理多重从机的响应信号和读取数据
   3. output stage
      1. 从输入级选择地址和控制信号和数据(仲裁)
      2. 确定何时在输入阶段的输入端口之间切换
      3. output只选择在寄存状态下的输入传输(一次传输中第一次会打一拍后面就不会了)
      4. 会生成响应的活动信号给input(表示我从机在忙)
2. 设计目的
   用于多层互联AHB,目的是改变移植性不强的multi连接的一组总线,取而代之的是多组lite总线(本质是给每个主机都配了一个decoder,给每个从机都加了仲裁).首先避免了一个多层互联总线的难更改性方便了脚本化(MUX很难改的),其次这使得不同主机可以映射出不同的从机地址,或者可以针对单个主机设计不同的remap方案
3. 问题:
   1. input stage明确了不连续的地址也需要有从机响应,但xml设置中可以使用非连续的映射地址,是否使用xml时,脚本会自动用slave_default去补齐不连续地址
   2. local slave和shared slave的区别
   local slave 指的是单独给某个master配置的从机
   shared slave 指的是给互联矩阵上接的从机

## Flash & Cache

1. 闪存物理构成
   1. package
   2. target(dies)
      独立的片选和接口,意味着不同target可以并行
   3. LUN
      由block组成
   4. block
      由page组成,可擦除最小单位
   5. page
      可编程最小单位(Flash可不能支持单纯的写覆盖,必须擦完再写)
   6. 闪存访问有个逻辑地址到物理页表的转换
2. 闪存逻辑构成
   1. 主存储块(按页擦除,按块写保护)
      1. 用户代码
      2. 数据
   2. 信息存储块
      1. 保密空间
      需要密钥配对
      1. 系统存储器
      出场的ISP bootloader
      1. 选项字节
      读写保护控制(反码验证),==已经有专门的flash空间了,为啥还要单独补对应的寄存器呢==
3. 闪存配置
   1. 需要根据时钟去设定预取延迟
   2. ==但报告里没说关闭cache后的延迟怎么设定==
4. 编程方式
   1. 在电编程-SWD烧录
   2. 在系统编程-UART串口
   3. 在应用编程-任何通讯方式,在程序中更新固件

## FSMC

内核对外部存储器的访问信号发送到AHB总线后，经过FSMC转换为符合外部存储器通信规约的信号，送到外部存储器的相应引脚，实现内核与外部存储器之间的数据交互。FSMC起到桥梁作用，既能够进行信号类型的转换，又能够进行信号宽度和时序的调整，屏蔽掉不同存储类型的差异
支持 NOR FLASH 6800 8080 SRAM拓展存储

## AHB to AHB

补充:当然降低面积也可以用MUX去把多个Slave合起来

## SDIO

## GPIO

1. GPIO功能
   1. 模拟输入
      * 直接将外部信号送入AD模块
   2. 浮空输入
      * 外部信号从管脚输入后经过TTL触发器输入到输入数据寄存器
   3. 上拉输入,下拉输入
      * 相比浮空输入,信号再进入触发器前接入了一个上拉/下拉电阻;
      * 浮空输入的电平在悬空状态下电平是不确定的,所以类似按键这种有一种情况是浮空态时,用上拉下拉可以将浮空态拉成电源或地
      * 提高抗干扰能力
      * 上拉电阻可以使得IO口输出有驱动能力的高电平
   4. 推挽输出(强0强1都能输出)
      * N-MOS和P-MOS都工作
      * 输出为0时,输出控制使得P-MOS关断,N-MOS导通,输出低电平
      * 输出为1时,输出控制使得P-MOS导通,N-MOS关断,输出为高电平
      * 开漏输出时,TTL触发器还在同时读取该输出端口的电平,输出电平一定是读取电平
   5. 开漏输出(只能输出强0)
      * 只有N-MOS工作,因为P-MOS管关断,N-MOS管的漏端相当于是开路,所以叫开漏输出
      * 输出为0时,输出控制使得N-MOS导通,输出低电平
      * 输出为1时,输出控制使得N-MOS关断,输出纯粹由上下拉方式去决定
      * 开漏输出时,TTL触发器还在同时读取该输出端口的电平,但是输出电平不一定是读取电平
   6. 复用推挽输出
      * GPIO复用为其他外设,输出寄存器无效,输出的高低电平来自于其他外设
   7. 复用开漏输出
       * GPIO复用为其他外设,输出寄存器无效,输出的高低电平来自于其他外设

## RCC

外部复位和内内部脉冲复位
内部脉冲复位主要是根据RCC_CSR中复位标志位来判断复位划分

1. 电源复位
   复位所有寄存器
   1. 上电复位
   POR的功能是在VDD电压由低向高上升越过规定的阀值之前，保持芯片复位，当越过这个阀值后的一小段时间后(图中的"滞后时间"或表中的"复位迟滞")，结束复位并取复位向量.
   2. 掉电复位
   PDR的功能是在VDD电压由高向低下降越过规定的阀值后，将在芯片内部产生复位,当然POR阈值比PDR要高一点
   3. 待机复位
   当待机模式被唤醒事件唤醒且退出后,产生待机复位==在手册详细部分里表面了备份域不会被复位,是不是有点矛盾==
2. 系统复位
   复位部分寄存器
   1. 外部复位
   外部按键输入低电平
   2. 窗口看门狗复位
   计数器大于设定复位,计数器小于0x40复位
   3. 独立看门狗复位
   从0xFFF递减直0后复位
   4. 软件复位
   配置相关寄存器,进行复位
   5. CPU死锁复位
   开启相关使能配置后,CPU进入锁定状态后复位
   6. PVD复位
   开启相关使能配置后,VDD低于阈值电压进行复位
   7. VDT复位
   开启相关使能配置后,1.5v域低于阈值电压进行复位
   8. 低功耗复位
   开启相关使能配置后,当程序介入低功耗模式时进行复位
3. 备份域复位
   配置相关寄存器位,备份域复位

复位后,处理器执行程序前,Cortex M处理器会读出向量表的前两个字,一个赋给MSP,一个赋给PC.
提前复位MSP的原因是因为,复位持续时,对于微控制器而言有产生NMI或HardFault等中断异常的可能,在异常处理前将处理器的状态压栈需要栈储存和MSP

## CRC

CRC 计算单元利用固定的多项式来计算 8 位、16 位或者 32位数据的 CRC 校验值，用于对数据传输或数据存储的完整性进行验证,该模块支持CRC-32(以太网),MPEG-2两种算法

CRC大致解读

* 二项式对应的就是二进制除数(ploy是去除首位的简式)
1(简式忽略)-0000-0100-1100-0001-0001-1101-1011-0111
04c11DB7

* 宽度:生成的校验位宽度

* 初始值:是给CRC计算一个初始值，可以是0，也可以是其他值;

* 结果异或值是把计算结果再异或某一个值；这么做的目的是防止全0数据的CRC一直为0。

* 输入数据反转是指输入数据以字节为单位按位逆序处理；输出数据反转是指CRC计算结果整体按位逆序处理；==是方便大小端操作吗==

1. 选定一个标准除数（K位二进制数据串）
2. 在要发送的数据（M位）后面加上K-1位0，然后将这个新数（M+K-1位）以模2除法的方式除以上面这个标准除数，所得到的余数也就是该数据的CRC校验码（注：余数必须比除数少且只少一位，不够就补0）
3. 将这个校验码附在原m位数据后面，构成新的M+K-1位数据，发送给接收端
4. 接收端将接收到的数据除以标准除数，如果余数为0则认为数据正确。

## AHB to APB

由AHB高速总线过渡到APB低速总线,以适配时钟频率要求不高的外设,因此也引入了不同的时钟域HCLK,PCLK

其解决方式是将一组握手信号用double-flops处理来进行数据传输的,只有数据稳定时,才会发出请求,当PCLK域收到数据后,完成握手,HCLK才会释放数据

APBACTIVE信号用于控制门控时钟PCLKG
如果没有APB传输事务,APBACTIVE将置低且停止时钟可以有效降低功耗

1. APB的地址只截取HADDR低16bit
2. APB只支持32bit传输

## UART I2C SPI CAN等APB外设协议接口

基本逻辑都是CPU或者DMA向该外设中的发送缓冲去填充数据
然后由外设逻辑去控制收发,缓存寄存器空时,才用再次填充

1. SPI
   * 全双工,有时钟,通讯是通过数据交换完成的，SPI是串行通讯协议，数据是一位一位的传输的。这就是SCLK时钟线存在的原因，由SCLK提供时钟脉冲，SDI，SDO则基于此脉冲完成数据传输。数据输出通过 SDO线，数据在时钟上升沿或下降沿时改变，在紧接着的下降沿或上升沿被读取。完成一位数据传输，输入也使用同样原理。因此，至少需要8次时钟信号的改变（上沿和下沿为一次），才能完成8位数据的传输。与普通的串行通讯不同，普通的串行通讯一次连续传送至少8位数据，而SPI允许数据一位一位的传送，甚至允许暂停，因为SCLK时钟线由主控设备控制，当没有时钟跳变时，从设备不采集或传送数据。也就是说，主设备通过对SCLK时钟线的控制可以完成对通讯的控制。
   *没有指定的流控制，没有应答机制确认是否接收到数据
2. I2C
   半双工,有时钟,但注意采样是在高电平时采样的,数据是在边沿切换的,有应答机制,如果主机要发送数据给从器件，则主机首先寻址从器件，然后主动发送数据至从器件，最后由主机终止数据传送；如果主机要接收从器件的数据，首先由主器件寻址从器件．然后主机接收从器件发送的数据，最后由主机终止接收过程
3. UART
   可全双工也可以单工,异步逻辑,采样由比波特率快的时钟进行采样.
   * 起始位：先发出一个逻辑”0”的信号，表示传输字符的开始。
   * 资料位：紧接着起始位之后。资料位的个数可以是4、5、6、7、8等，构成一个字符。通常采用ASCII码。从最低位开始传送，靠时钟定位。
   * 奇偶校验位：资料位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验资料传送的正确性。
   * 停止位：它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。
   * 空闲位：处于逻辑“1”状态，表示当前线路上没有资料传送。
   * 波特率：是衡量资料传送速率的指标。表示每秒钟传送的符号数（symbol）由于UART是串行二进制传输,其波特率就等于一个数据位时长的倒数
4. CAN
   当一个站要向其它站发送数据时，该站的CPU将要发送的数据和自己的标识符传送给本站的CAN芯片，并处于准备状态；当它收到总线分配时，转为发送报文状态。CAN芯片将数据根据协议组织成一定的报文格式发出，这时网上的其它站处于接收状态。每个处于接收状态的站对接收到的报文进行检测，判断这些报文是否是发给自己的，以确定是否接收它。由于CAN总线是一种面向内容的编址方案，因此很容易建立高水准的控制系统并灵活地进行配置。我们可以很容易地在CAN总线中加进一些新站而无需在硬件或软件上进行修改。当所提供的新站是纯数据接收设备时，数据传输协议不要求独立的部分有物理目的地址。它允许分布过程同步化，即总线上控制器需要测量数据时，可由网上获得，而无须每个控制器都有自己独立的传感器

## timer

主要功能构成还是寄存器+计数器的组合,能为用户提供便捷的计数或定时功能

自习区

1. 问题
   * 时钟源的内部触发输入是指什么?
   * 计数器的自动装载是怎么完成的,为什么是8位可编程的,而定时器是16位的?
   * 外部信号控制定时器并且能够实现定时器间互连的同步电路这是什么意思?
   * 输入捕获,脉冲宽度和周期测量是怎么完成的
   * 什么叫逐周期管理
   * 编码器和霍尔传感器的用途?
   * 比较输出是指什么?
   * 死区时间是什么,什么是边沿对齐,什么是中央对齐模式?
   * 刹车输入是指什么?输出信号的状态又是指什么
   * 怎么输出单脉冲输出?
   * 更新事件和触发事件的不同之处在哪?
  
2. 模块拆解
   1. 时钟
      1. 内部时钟
      2. 外部触发:==TRGI,TIx,ITRx,ETRX==
         * TRGI(触发输入):计数器由TIx,ITRx,ETRX的输入信号的上升沿和下降沿驱动
         * TIx:就是定时器的外部输入通道
         * ITRx:是触发定时器的专用内部管教,可由其他触发器触发,方便级联
         * ETRx:是触发定时器的专用外部管脚
      3. 外部触发:==ETRx==
         * ETRx:是触发定时器的专用外部管脚
      4. 编码器模式
         * 类似记录姿态的,两组TIx输入控制的有极性的时钟,此时是不能使用外部时钟入口的,因为数量不够
      5. 问题
         * 为什么要分成两个外部输入呢,尤其是2方式输入还是1方式的子集
            因为模式一的通道TRGI还有从模式,比如输入事件复位,清零,门控,如需这些从模式并需求外部时钟时,就需要外部触发2模式了
         * 那为什么不单独把ETR拿出来,还在模式一里面加入呢?
            因为如果要使ETR作为从模式触发信号需要啊,模式一相当于可以作为选作为时钟输入,也可以选作为从模式输入
   2. 时基单元
      1. 计数器CNT
         * 每个时钟可+1-1
      2. 预分频器PSC
         * 对定时器时钟进行分频作为计数器的时钟
      3. 自动预装寄存器ARR(这个自动装载这个功能不错,节省了软件重新装填的周期)
         * 向上计数时，当计数器的值CNT从0计数到ARR的值的时候，会产生溢出中断（也叫更新中断，update interrupt），然后会清零重新计数
         * 向下计数时，当计数器的值CNT从ARR的值计数到0的时候会产生溢出中断，然后会重新填充ARR的值
         * 中央对齐时,当计数器的值CNT从0计数到ARR-1时,产生上溢,然后递减至1,产生下溢,但计数器的值还是从0到ARR再到0;
         * EGR寄存器UG位类似复位效果能让计数器重置,且生成一个事件
      4. 重复计数器(高级定时器独有的)
         * 向上计数时，我们把REP的值设置成10，如果有设置当计数器溢出的时候，那么此时不会产生中断，而是REP_CNT的值+1，当加到10的时候才产生中断，向下计数原理类似，只不过是从10减到0
   3. 输入捕获单元
      1. 输入通道引脚
         * 有CH1,CH2,CH3的异或霍尔接口
      2. 输入滤波器和边沿检测器
         * 信号受到干扰时，滤波器可以对输入信号进行滤波
         * 数字滤波器可配置采样频率和滤波宽度
         * 边沿检测可以选择捕获什么边沿
      3. 捕获模式选择
         * 两两一对,加上TRC,可以再每对之间的输入信号和内部触发来源(TRC)三者选择,两两一对是方便PWM捕获
      4. 分频器
         * 决定发生多少个事件时进行一次捕获,如果希望捕获信号的每一个边沿，则不分频
      5. 捕获寄存器
         * 当发生捕获时（第一次），计数器CNT 的值会被锁存到捕获寄存器 CCR 中，还会产生 CCxI 中断，相应的中断位 CCxIF（在SR 寄存器中）会被置位，通过软件或者读取 CCR 中的值可以将 CCxIF 清 0
         * 如果发生第二次捕获（即重复捕获： CCR 寄存器中已捕获到计数器值且 CCxIF 标志已置 1），则捕获溢出标志位 CCxOF（在 SR 寄存器中）会被置位， CCxOF 只能通过软件清零
   4. 比较输出
      1. 比较寄存器
         * 可输出(区别于ARR)
         * 会更新标志
         * 能根据配置产生中断
         * 能根据配置产生DMA请求
      2. 死区事件生成
         * 可以插入死区时间，用于生成两路互补的输出信号的都无效区域(避免因外部器件导致驱动电路同时导通)
      3. 输出控制
         * 强制输出
         * 根据设定,比较匹配时输出通道有几种不同的操作
           * 保持
           * 置位
           * 无效
           * 反转
      4. 输出引脚

3. Timer1/8高级定时器(16位)

4. Timer2/3/4/5通用定时器(32位/16位)
   1. 功能
5. TImer6/7基本定时器(16位)
   1. 功能

## ADC&Sensor

## DAC

## 比较器

## EXIT中断事件控制器

## DBG调试控制器

## CRS时钟回馈系统

## SYSCFG配置寄存器

## BKP备份寄存器